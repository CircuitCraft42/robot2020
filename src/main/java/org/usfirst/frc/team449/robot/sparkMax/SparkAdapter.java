package org.usfirst.frc.team449.robot.sparkMax;

import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import edu.wpi.first.wpilibj.shuffleboard.EventImportance;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import org.jetbrains.annotations.Contract;

/**
 * Spark with trivial-to-implement {@link BaseMotorController} methods.
 */
public class SparkAdapter extends CANSparkMax
{
    protected double setpoint;
    protected ControlType controlType;

    SparkAdapter(final int deviceID, final MotorType type) {
        super(deviceID, type);
    }

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos Position to set for the selected sensor (in raw sensor units).
     * @param pidIdx    0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for
     *                  config success and report an error if it times out.
     *                  If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#setSelectedSensorPosition(int, int, int)
     */
    public CANError setSelectedSensorPosition(final int sensorPos, final int pidIdx, final int timeoutMs) {
        // TODO: setEncPosition() is actually protected, so we might be breaking something by calling it.
        this.setEncPosition(sensorPos);
        return CANError.kOk;
    }

    /**
     * @param outputValue The value to set, which depends on the control mode:
     *                    * For basic control using duty cycle, this should range between -1 and 1.
     *                    * For voltage control, this is the voltage in volts.
     *                    * For velocity control, this is the angular velocity in RPM.
     *                    * For position control, this is the rotation value.
     *                    * For current control, this is the current in amps.
     * @param mode        The control type to override with.
     * @see BaseMotorController#set(com.ctre.phoenix.motorcontrol.ControlMode, double, double)
     */
    public void set(final ControlType mode, final double outputValue) {
        Shuffleboard.addEventMarker("setReference: mode=" + mode + " value=" + outputValue, this.getClass().getSimpleName(), EventImportance.kNormal);
        System.out.println("setReference: mode=" + mode + " value=" + outputValue);

        this.getPIDController().setReference(outputValue, mode);

        // Keep track of the parameter values so we can examine them later if necessary.
        this.setpoint = outputValue;
        this.controlType = mode;
    }

    public void setFromPoint(final double pos, final double vel, final double acc) {
        this.set(ControlType.kSmartMotion, pos);
        this.getPIDController().setSmartMotionMaxVelocity(vel, 0); // TODO This must be changed if we have slot-switching
        this.getPIDController().setSmartMotionMaxAccel(acc, 0);
    }

    public void setFromPoint(final TrajectoryPoint point) {
        this.setFromPoint(point.position, point.velocity, 0);
    }

    public double getSetPoint() {
        return this.setpoint;
    }

    /**
     * @see BaseMotorController#getControlMode()
     */
    @Contract(pure = true)
    public ControlType getControlType() {
        return this.controlType;
    }

    /**
     * Replicates the implementation of {@link BaseMotorController#getMotorOutputVoltage()}
     *
     * @return applied voltage to motor in volts
     */
    public double getMotorOutputVoltage() {
        return this.getAppliedOutput() * this.getBusVoltage();
    }
}
