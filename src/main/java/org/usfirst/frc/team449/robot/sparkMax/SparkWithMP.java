package org.usfirst.frc.team449.robot.sparkMax;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.revrobotics.CANError;
import com.revrobotics.ControlType;
import edu.wpi.first.wpilibj.Notifier;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.usfirst.frc.team449.robot.other.Clock;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Spark implementing additional {@link BaseMotorController} functionality, primarily pertaining to motion profile execution.
 */
public class SparkWithMP extends SparkAdapter { // TODO Perhaps bite the bullet and just implement BaseMotorController here so SparkWrapper and FPSTalon can be unified?
    public static final int MotionProfileBufferCapacity = 2048;
    /**
     * Trajectory points (called the buffer by CTRE)
     */
    private final Queue<TrajectoryPoint> pointQueue = new ConcurrentLinkedQueue<>();
    private final Notifier mpNotifier;
    private final double mpExecutorPeriodSecs;
    private int basePointDuration;
    private boolean isUnderrun = true;
    private TrajectoryPoint activePoint;
    private long activePointActivationTime;
    /**
     * Set if {@code isUnderrun} ever gets set. Only is cleared by
     * clearMotionProfileHasUnderrun() to ensure robot logic can react or
     * instrument it.
     *
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    private boolean hasUnderrun;

    SparkWithMP(final int deviceID, final MotorType type, double mpExecutorPeriodSecs) {
        super(deviceID, type);
        this.mpExecutorPeriodSecs = mpExecutorPeriodSecs;

        //Set up notifier for MP execution.
        this.mpNotifier = new Notifier(this::processMP);
    }

    private static String trajPointToStr(TrajectoryPoint pt) {
        return "TrajectoryPoint(" +
                "Position: " +
                pt.position +
                ", Velocity: " +
                pt.velocity +
                ")";
    }

    public void set(final ControlType mode, final double outputValue) {
        this.disableMP();
        super.set(mode, outputValue);
    }

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     * <p>
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     *
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     *                           This is summed with the trajectory points unique timeDur.
     * @param timeoutMs          Timeout value in ms. If nonzero, function will wait for
     *                           config success and report an error if it times out.
     *                           If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public CANError configMotionProfileTrajectoryPeriod(final int baseTrajDurationMs, final int timeoutMs) {
        this.basePointDuration = baseTrajDurationMs;
        return CANError.kOk;
    }

    @Contract(pure = true)
    public void copyStatusTo(final MotionProfileStatus statusToFill) {
        statusToFill.topBufferRem = this.getBufferRemaining();
        statusToFill.topBufferCnt = 0; // Always zero because all pushed points are immediately ready for execution.
        statusToFill.btmBufferCnt = this.getMotionProfileTopLevelBufferCount();
        statusToFill.hasUnderrun = this.hasUnderrun();
        statusToFill.isUnderrun = this.isUnderrun();
        statusToFill.activePointValid = this.isActivePointValid();
        statusToFill.isLast = this.isLast();
    }

    public CANError getMotionProfileStatus(@NotNull final MotionProfileStatus statusToFill) {
        this.copyStatusTo(statusToFill);
        return CANError.kOk;
    }

    @Contract(pure = true)
    public int getMotionProfileTopLevelBufferCount() {
        return this.pointQueue.size();
    }

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for config
     *                  success and report an error if it times out. If zero, no
     *                  blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    void clearMotionProfileHasUnderrun(final int timeoutMs) {
        this.hasUnderrun = false;
    }

    void clearMotionProfileTrajectories() {
        this.disableMP();
        this.pointQueue.clear();
    }

    public void disableMP() {
        this.mpNotifier.stop();
    }

    @Override
    public void disable() {
        this.disableMP();
        super.disable();
    }

    ErrorCode pushMPPoint(final TrajectoryPoint pt) {
        // According to Talon' documentation, BaseMotorController returns
        // "CTR_OKAY if trajectory point push ok. ErrorCode if buffer is full due to kMotionProfileTopBufferCapacity."
        if (this.getBufferRemaining() <= 0) return ErrorCode.BufferFull;
        this.pointQueue.add(pt);
        return ErrorCode.OK;
    }

    /**
     * The number of available empty slots in the trajectory buffer.
     */
    @Contract(pure = true)
    public int getBufferRemaining() {
        return SparkWithMP.MotionProfileBufferCapacity - this.getMotionProfileTopLevelBufferCount();
    }

    @Contract(pure = true)
    public boolean hasUnderrun() {
        return this.hasUnderrun;
    }

    /**
     * This is set if Talon/Victor needs to shift a point from its buffer into the
     * active trajectory point however the buffer is empty. This gets cleared
     * automatically when is resolved.
     */
    @Contract(pure = true)
    public boolean isUnderrun() {
        return this.isUnderrun;
    }

    /**
     * True if the active trajectory point is the last point of the profile.
     */
    @Contract(pure = true)
    public boolean isLast() {
        return !this.pointQueue.isEmpty() && this.pointQueue.peek().isLastPoint;
    }

    /**
     * True if the active trajectory point is not empty, false otherwise. The
     * members in activePoint are only valid if this signal is set.
     */
    @Contract(pure = true)
    public boolean isActivePointValid() {
        return !this.isUnderrun(); // TODO: Actually whether the point is empty.
    }

    @Contract(pure = true)
    public TrajectoryPoint activePoint() {
        return this.activePoint;
    }

    /**
     * The duration in ms of the current trajectory point.
     */
    @Contract(pure = true)
    public int getTimeDurMs() {
        return this.basePointDuration + this.activePoint().timeDur;
    }

    /**
     * Moves on to the next point if the active point needs to be consumed.
     */
    protected void processMP() {
        boolean shouldConsume = this.activePointShouldBeConsumed();
        if (shouldConsume) this.moveToNextPoint();
    }

    private void moveToNextPoint() {
        final TrajectoryPoint newActivePoint = this.activePoint = this.pointQueue.poll();
        if (newActivePoint != null) System.out.println("New active point: " + trajPointToStr(newActivePoint));
        this.hasUnderrun |= (this.isUnderrun = newActivePoint == null);
        if (!this.isUnderrun) {
            this.setFromPoint(this.activePoint());
            this.activePointActivationTime = Clock.currentTimeMillis();
        }
    }

    @Contract(pure = true)
    private boolean activePointShouldBeConsumed() {
        // Always if we're underrun.
        if (!this.isActivePointValid()) return true;

        // Check if the current point has been running for its target duration.
        return this.getTimeDurMs() >= Clock.currentTimeMillis() - this.activePointActivationTime;
    }

    public void setMP() {
        this.mpNotifier.startPeriodic(this.mpExecutorPeriodSecs);
    }
}
